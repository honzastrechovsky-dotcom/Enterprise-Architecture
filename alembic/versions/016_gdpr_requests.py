"""Add gdpr_requests table for GDPR data subject request tracking.

Revision ID: 016
Revises: 015
Create Date: 2026-02-17

Phase 11A6: Replaces in-memory GDPR request stubs with a persistent table.
Implements Article 15 (access), Article 17 (erasure), and Article 20
(portability) request lifecycle tracking, including the 30-day compliance
deadline mandated by GDPR.

Table: gdpr_requests
  - id              UUID PK (gen_random_uuid())
  - tenant_id       UUID  NOT NULL, FK → tenants(id), indexed
  - user_id         UUID  NOT NULL (subject's internal user ID, indexed)
  - request_type    VARCHAR(50)  access | erasure | portability
  - status          VARCHAR(50)  pending | in_progress | completed | failed | rejected
  - requested_at    TIMESTAMP WITH TIME ZONE  (NOT NULL, default now())
  - completed_at    TIMESTAMP WITH TIME ZONE  (nullable)
  - deadline_at     TIMESTAMP WITH TIME ZONE  (NOT NULL — 30 days from request)
  - notes           TEXT  (nullable — operator comments)
  - result_data     JSONB (nullable — access/portability export payload)

Indexes:
  - idx_gdpr_requests_tenant  (tenant_id)   — list requests per tenant
  - idx_gdpr_requests_user    (user_id)     — find all requests for a subject

Notes:
  - user_id is the internal users.id (UUID) of the data subject.
    The DataSubjectRequest dataclass uses subject_email for human display,
    but persistence uses the user_id for consistency with other tables.
  - FK to tenants(id) with ON DELETE CASCADE: when a tenant is hard-deleted
    (extreme edge case) all GDPR requests are also removed.
  - No FK to users.id because a user may be anonymised/deleted as part of
    an erasure request — the GDPR record must outlive the user row.
  - status stored as VARCHAR to avoid PostgreSQL enum migration pain.
"""

from __future__ import annotations

from collections.abc import Sequence

import sqlalchemy as sa
from sqlalchemy.dialects import postgresql

from alembic import op

revision: str = "016"
down_revision: str | None = "015"
branch_labels: str | Sequence[str] | None = None
depends_on: str | Sequence[str] | None = None


def upgrade() -> None:
    """Create gdpr_requests table with indexes."""

    op.create_table(
        "gdpr_requests",

        sa.Column(
            "id",
            postgresql.UUID(as_uuid=True),
            primary_key=True,
            nullable=False,
            server_default=sa.text("gen_random_uuid()"),
            comment="GDPR request primary key — generated by PostgreSQL",
        ),
        sa.Column(
            "tenant_id",
            postgresql.UUID(as_uuid=True),
            sa.ForeignKey("tenants.id", ondelete="CASCADE"),
            nullable=False,
            comment="Owning tenant — all queries must filter on this column",
        ),
        sa.Column(
            "user_id",
            postgresql.UUID(as_uuid=True),
            nullable=False,
            comment=(
                "Internal user ID of the data subject. "
                "No FK to users — user row may be anonymised by an erasure request."
            ),
        ),
        sa.Column(
            "request_type",
            sa.String(50),
            nullable=False,
            comment="access | erasure | portability  (GDPR Art. 15, 17, 20)",
        ),
        sa.Column(
            "status",
            sa.String(50),
            nullable=False,
            server_default="pending",
            comment="pending | in_progress | completed | failed | rejected",
        ),
        sa.Column(
            "requested_at",
            sa.DateTime(timezone=True),
            nullable=False,
            server_default=sa.func.now(),
            comment="UTC timestamp of request submission",
        ),
        sa.Column(
            "completed_at",
            sa.DateTime(timezone=True),
            nullable=True,
            comment="UTC timestamp when the request reached a terminal status",
        ),
        sa.Column(
            "deadline_at",
            sa.DateTime(timezone=True),
            nullable=False,
            comment="Compliance deadline — 30 days from requested_at per GDPR Art. 12(3)",
        ),
        sa.Column(
            "notes",
            sa.Text(),
            nullable=True,
            comment="Operator notes, rejection reason, or processing comments",
        ),
        sa.Column(
            "result_data",
            postgresql.JSONB,
            nullable=True,
            comment=(
                "Serialised export payload for access/portability requests. "
                "NULL for erasure requests or while pending."
            ),
        ),
    )

    op.create_index(
        "idx_gdpr_requests_tenant",
        "gdpr_requests",
        ["tenant_id"],
        comment="List GDPR requests for a tenant (compliance dashboard query)",
    )

    op.create_index(
        "idx_gdpr_requests_user",
        "gdpr_requests",
        ["user_id"],
        comment="Find all GDPR requests for a specific data subject",
    )


def downgrade() -> None:
    """Drop gdpr_requests table and its indexes."""

    op.drop_index("idx_gdpr_requests_user", table_name="gdpr_requests")
    op.drop_index("idx_gdpr_requests_tenant", table_name="gdpr_requests")
    op.drop_table("gdpr_requests")
