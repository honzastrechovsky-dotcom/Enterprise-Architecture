"""Internationalization (i18n) and localization (l10n) for global deployments.

Supports 10 languages for global operations:
- English (EN) - Primary
- German (DE) - Europe
- Czech (CS) - Europe
- Chinese (ZH) - Asia Pacific
- Japanese (JA) - Asia Pacific
- Korean (KO) - Asia Pacific
- Spanish (ES) - Americas, Europe
- French (FR) - Europe, Africa
- Portuguese (PT) - Americas, Europe
- Polish (PL) - Europe

Translation strategy:
- LLM-based translation for document content and user queries
- Pre-built UI string translations for system messages
- Language detection via LLM inference
- AI disclosure translations for compliance

All translations preserve:
- Technical terminology accuracy
- Security classification markings
- Citations and metadata
"""

from __future__ import annotations

import json
from enum import StrEnum

import structlog
from httpx import AsyncClient

from src.config import get_settings

log = structlog.get_logger(__name__)


class SupportedLanguage(StrEnum):
    """Supported languages for TE global operations."""

    EN = "en"  # English (primary)
    DE = "de"  # German
    CS = "cs"  # Czech
    ZH = "zh"  # Chinese (Simplified)
    JA = "ja"  # Japanese
    KO = "ko"  # Korean
    ES = "es"  # Spanish
    FR = "fr"  # French
    PT = "pt"  # Portuguese
    PL = "pl"  # Polish


# Pre-built UI strings for system messages (core set; extend for additional coverage)
UI_STRINGS: dict[SupportedLanguage, dict[str, str]] = {
    SupportedLanguage.EN: {
        "ai_disclosure": "This response was generated by an AI assistant. Please verify critical information.",
        "error_generic": "An error occurred. Please try again.",
        "error_rate_limit": "Rate limit exceeded. Please wait before retrying.",
        "error_auth": "Authentication required.",
        "error_permission": "You do not have permission to perform this action.",
        "success_saved": "Saved successfully.",
        "success_deleted": "Deleted successfully.",
        "label_search": "Search",
        "label_cancel": "Cancel",
        "label_confirm": "Confirm",
    },
    SupportedLanguage.DE: {
        "ai_disclosure": "Diese Antwort wurde von einem KI-Assistenten erstellt. Bitte überprüfen Sie kritische Informationen.",
        "error_generic": "Ein Fehler ist aufgetreten. Bitte versuchen Sie es erneut.",
        "error_rate_limit": "Ratenlimit überschritten. Bitte warten Sie, bevor Sie es erneut versuchen.",
        "error_auth": "Authentifizierung erforderlich.",
        "error_permission": "Sie haben keine Berechtigung, diese Aktion auszuführen.",
        "success_saved": "Erfolgreich gespeichert.",
        "success_deleted": "Erfolgreich gelöscht.",
        "label_search": "Suchen",
        "label_cancel": "Abbrechen",
        "label_confirm": "Bestätigen",
    },
    SupportedLanguage.CS: {
        "ai_disclosure": "Tato odpověď byla vygenerována AI asistentem. Ověřte prosím kritické informace.",
        "error_generic": "Došlo k chybě. Zkuste to prosím znovu.",
        "error_rate_limit": "Překročen limit. Počkejte prosím před opakováním.",
        "error_auth": "Vyžaduje se autentizace.",
        "error_permission": "Nemáte oprávnění k provedení této akce.",
        "success_saved": "Úspěšně uloženo.",
        "success_deleted": "Úspěšně smazáno.",
        "label_search": "Hledat",
        "label_cancel": "Zrušit",
        "label_confirm": "Potvrdit",
    },
    SupportedLanguage.ZH: {
        "ai_disclosure": "此回复由AI助手生成。请验证关键信息。",
        "error_generic": "发生错误。请重试。",
        "error_rate_limit": "超出速率限制。请稍后重试。",
        "error_auth": "需要身份验证。",
        "error_permission": "您无权执行此操作。",
        "success_saved": "保存成功。",
        "success_deleted": "删除成功。",
        "label_search": "搜索",
        "label_cancel": "取消",
        "label_confirm": "确认",
    },
    SupportedLanguage.JA: {
        "ai_disclosure": "この応答はAIアシスタントによって生成されました。重要な情報を確認してください。",
        "error_generic": "エラーが発生しました。再試行してください。",
        "error_rate_limit": "レート制限を超えました。しばらくしてから再試行してください。",
        "error_auth": "認証が必要です。",
        "error_permission": "このアクションを実行する権限がありません。",
        "success_saved": "正常に保存されました。",
        "success_deleted": "正常に削除されました。",
        "label_search": "検索",
        "label_cancel": "キャンセル",
        "label_confirm": "確認",
    },
    SupportedLanguage.KO: {
        "ai_disclosure": "이 응답은 AI 어시스턴트가 생성했습니다. 중요한 정보를 확인하세요.",
        "error_generic": "오류가 발생했습니다. 다시 시도하세요.",
        "error_rate_limit": "속도 제한을 초과했습니다. 잠시 후 다시 시도하세요.",
        "error_auth": "인증이 필요합니다.",
        "error_permission": "이 작업을 수행할 권한이 없습니다.",
        "success_saved": "성공적으로 저장되었습니다.",
        "success_deleted": "성공적으로 삭제되었습니다.",
        "label_search": "검색",
        "label_cancel": "취소",
        "label_confirm": "확인",
    },
    SupportedLanguage.ES: {
        "ai_disclosure": "Esta respuesta fue generada por un asistente de IA. Verifique la información crítica.",
        "error_generic": "Ocurrió un error. Inténtelo de nuevo.",
        "error_rate_limit": "Límite de tasa excedido. Espere antes de reintentar.",
        "error_auth": "Se requiere autenticación.",
        "error_permission": "No tiene permiso para realizar esta acción.",
        "success_saved": "Guardado exitosamente.",
        "success_deleted": "Eliminado exitosamente.",
        "label_search": "Buscar",
        "label_cancel": "Cancelar",
        "label_confirm": "Confirmar",
    },
    SupportedLanguage.FR: {
        "ai_disclosure": "Cette réponse a été générée par un assistant IA. Veuillez vérifier les informations critiques.",
        "error_generic": "Une erreur s'est produite. Veuillez réessayer.",
        "error_rate_limit": "Limite de débit dépassée. Veuillez attendre avant de réessayer.",
        "error_auth": "Authentification requise.",
        "error_permission": "Vous n'avez pas la permission d'effectuer cette action.",
        "success_saved": "Enregistré avec succès.",
        "success_deleted": "Supprimé avec succès.",
        "label_search": "Rechercher",
        "label_cancel": "Annuler",
        "label_confirm": "Confirmer",
    },
    SupportedLanguage.PT: {
        "ai_disclosure": "Esta resposta foi gerada por um assistente de IA. Verifique informações críticas.",
        "error_generic": "Ocorreu um erro. Tente novamente.",
        "error_rate_limit": "Limite de taxa excedido. Aguarde antes de tentar novamente.",
        "error_auth": "Autenticação necessária.",
        "error_permission": "Você não tem permissão para executar esta ação.",
        "success_saved": "Salvo com sucesso.",
        "success_deleted": "Excluído com sucesso.",
        "label_search": "Pesquisar",
        "label_cancel": "Cancelar",
        "label_confirm": "Confirmar",
    },
    SupportedLanguage.PL: {
        "ai_disclosure": "Ta odpowiedź została wygenerowana przez asystenta AI. Zweryfikuj krytyczne informacje.",
        "error_generic": "Wystąpił błąd. Spróbuj ponownie.",
        "error_rate_limit": "Przekroczono limit. Poczekaj przed ponowną próbą.",
        "error_auth": "Wymagana autentykacja.",
        "error_permission": "Nie masz uprawnień do wykonania tej akcji.",
        "success_saved": "Zapisano pomyślnie.",
        "success_deleted": "Usunięto pomyślnie.",
        "label_search": "Szukaj",
        "label_cancel": "Anuluj",
        "label_confirm": "Potwierdź",
    },
}


class TranslationService:
    """LLM-based translation service for user content.

    Uses the configured LiteLLM proxy with the light-tier model for
    language detection and translation tasks.

    Usage:
        service = TranslationService()

        # Detect language
        lang = await service.detect_language("Hello, world!")

        # Translate text
        translated = await service.translate(
            text="Hello, world!",
            source=SupportedLanguage.EN,
            target=SupportedLanguage.DE,
        )

        # Get UI strings
        strings = service.localize_ui_strings(SupportedLanguage.DE)
    """

    def __init__(self) -> None:
        """Initialize the translation service."""
        self.settings = get_settings()

    async def detect_language(self, text: str) -> SupportedLanguage:
        """Detect the language of text using LLM.

        Args:
            text: Text to analyze

        Returns:
            Detected SupportedLanguage (defaults to EN if uncertain)
        """
        if not text.strip():
            return SupportedLanguage.EN

        try:
            async with AsyncClient(timeout=30.0) as client:
                response = await client.post(
                    f"{self.settings.litellm_base_url}/chat/completions",
                    headers={"Authorization": f"Bearer {self.settings.litellm_api_key.get_secret_value()}"},
                    json={
                        "model": self.settings.model_light,
                        "messages": [
                            {
                                "role": "system",
                                "content": (
                                    "You are a language detection expert. Respond with ONLY the ISO 639-1 "
                                    "language code (e.g., 'en', 'de', 'zh'). Supported: en, de, cs, zh, ja, ko, es, fr, pt, pl."
                                ),
                            },
                            {
                                "role": "user",
                                "content": f"Detect the language of this text:\n\n{text[:500]}",
                            },
                        ],
                        "temperature": 0.0,
                        "max_tokens": 10,
                    },
                )
                response.raise_for_status()
                result = response.json()
                detected = result["choices"][0]["message"]["content"].strip().lower()

                # Validate against supported languages
                try:
                    return SupportedLanguage(detected)
                except ValueError:
                    log.warning("i18n.unsupported_language_detected", detected=detected)
                    return SupportedLanguage.EN

        except Exception as exc:
            log.error("i18n.detection_failed", error=str(exc), exc_info=True)
            return SupportedLanguage.EN

    async def translate(
        self,
        text: str,
        source: SupportedLanguage,
        target: SupportedLanguage,
    ) -> str:
        """Translate text from source to target language.

        Args:
            text: Text to translate
            source: Source language
            target: Target language

        Returns:
            Translated text

        Raises:
            RuntimeError: If translation fails
        """
        if source == target:
            return text

        if not text.strip():
            return text

        try:
            async with AsyncClient(timeout=60.0) as client:
                response = await client.post(
                    f"{self.settings.litellm_base_url}/chat/completions",
                    headers={"Authorization": f"Bearer {self.settings.litellm_api_key.get_secret_value()}"},
                    json={
                        "model": self.settings.model_light,
                        "messages": [
                            {
                                "role": "system",
                                "content": (
                                    f"You are a professional translator. Translate the following text from "
                                    f"{source.upper()} to {target.upper()}. Preserve technical terminology, "
                                    "formatting, and any classification markings. Respond with ONLY the translation."
                                ),
                            },
                            {
                                "role": "user",
                                "content": text,
                            },
                        ],
                        "temperature": 0.3,
                        "max_tokens": len(text) * 2,  # Generous token budget
                    },
                )
                response.raise_for_status()
                result = response.json()
                translated = result["choices"][0]["message"]["content"].strip()

                log.info(
                    "i18n.translation_completed",
                    source=source,
                    target=target,
                    source_length=len(text),
                    target_length=len(translated),
                )

                return translated

        except Exception as exc:
            log.error("i18n.translation_failed", error=str(exc), exc_info=True)
            raise RuntimeError(f"Translation failed: {exc}")

    def localize_ui_strings(self, language: SupportedLanguage) -> dict[str, str]:
        """Get pre-translated UI strings for a language.

        Args:
            language: Target language

        Returns:
            Dictionary of UI string keys to translated values
        """
        return UI_STRINGS.get(language, UI_STRINGS[SupportedLanguage.EN])


class DocumentLanguageProcessor:
    """Process documents for multilingual search and retrieval.

    Handles:
    - Document language detection
    - Document translation for cross-language RAG
    - Multilingual keyword extraction for search
    """

    def __init__(self) -> None:
        """Initialize the document processor."""
        self.translation_service = TranslationService()

    async def detect_document_language(self, content: str) -> SupportedLanguage:
        """Detect the primary language of a document.

        Args:
            content: Document content (full or sample)

        Returns:
            Detected SupportedLanguage
        """
        # Sample first 1000 chars for detection
        sample = content[:1000]
        return await self.translation_service.detect_language(sample)

    async def translate_document(
        self,
        content: str,
        target: SupportedLanguage,
        source: SupportedLanguage | None = None,
    ) -> str:
        """Translate a document to target language.

        Args:
            content: Document content
            target: Target language
            source: Source language (auto-detected if None)

        Returns:
            Translated document content
        """
        if source is None:
            source = await self.detect_document_language(content)

        if source == target:
            return content

        # Translate the full document in one call.
        # For very long documents, consider chunked translation with context preservation.
        return await self.translation_service.translate(content, source, target)

    async def extract_multilingual_keywords(self, content: str) -> list[str]:
        """Extract keywords in multiple languages for search.

        Uses LLM to extract key terms that would be useful across
        language boundaries (technical terms, proper nouns, etc.).

        Args:
            content: Document content

        Returns:
            List of multilingual keywords
        """
        settings = get_settings()

        try:
            async with AsyncClient(timeout=30.0) as client:
                response = await client.post(
                    f"{settings.litellm_base_url}/chat/completions",
                    headers={"Authorization": f"Bearer {settings.litellm_api_key.get_secret_value()}"},
                    json={
                        "model": settings.model_light,
                        "messages": [
                            {
                                "role": "system",
                                "content": (
                                    "Extract 5-10 key technical terms, proper nouns, and important keywords "
                                    "from the document. Return as a JSON array of strings."
                                ),
                            },
                            {
                                "role": "user",
                                "content": content[:2000],  # Sample
                            },
                        ],
                        "temperature": 0.0,
                        "max_tokens": 200,
                    },
                )
                response.raise_for_status()
                result = response.json()
                keywords_json = result["choices"][0]["message"]["content"].strip()

                # Parse JSON array
                keywords = json.loads(keywords_json)
                return keywords if isinstance(keywords, list) else []

        except Exception as exc:
            log.error("i18n.keyword_extraction_failed", error=str(exc), exc_info=True)
            return []
