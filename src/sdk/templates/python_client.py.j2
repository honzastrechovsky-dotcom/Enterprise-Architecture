# AUTO-GENERATED - do not edit manually.
# Generated by Enterprise Agent Platform SDK Generator v{{ version }}
# Source: {{ title }} {{ version }}
# {{ description }}
"""{{ title }} Python Client (auto-generated).

Async client built on httpx with Pydantic v2 models.

Usage::

    import asyncio
    from eap_client import EAPClient

    async def main():
        client = EAPClient(
            base_url="{{ base_url }}",
            bearer_token="<your-jwt-token>",  # or api_key="<key>"
        )
        # Example: list webhooks
        result = await client.list_webhooks()
        print(result)

    asyncio.run(main())
"""

from __future__ import annotations

import json
from typing import Any

import httpx
from pydantic import BaseModel, Field


# ------------------------------------------------------------------ #
# Exceptions
# ------------------------------------------------------------------ #

class EAPAPIError(Exception):
    """Raised when the API returns a non-2xx HTTP response."""

    def __init__(self, status_code: int, detail: Any) -> None:
        self.status_code = status_code
        self.detail = detail
        super().__init__(f"EAP API error {status_code}: {detail}")


class EAPAuthError(EAPAPIError):
    """Raised on 401 Unauthorized responses."""


class EAPForbiddenError(EAPAPIError):
    """Raised on 403 Forbidden responses."""


class EAPNotFoundError(EAPAPIError):
    """Raised on 404 Not Found responses."""


class EAPRateLimitError(EAPAPIError):
    """Raised on 429 Too Many Requests responses."""


# ------------------------------------------------------------------ #
# Pydantic models (generated from OpenAPI schemas)
# ------------------------------------------------------------------ #

{% for name, schema in schemas.items() %}
{% set props = schema.get('properties', {}) %}
class {{ name | pascal_case }}(BaseModel):
    """{{ schema.get('description', name + ' model.') }}"""
    {% if props %}
    {% for prop_name, prop_schema in props.items() %}
    {% set py_type = python_type(prop_schema) %}
    {% set required = prop_name in schema.get('required', []) %}
    {% if required %}
    {{ prop_name | snake_case }}: {{ py_type }} = Field(
        ...,
        description={{ (prop_schema.get('description', '') or '') | repr }},
    )
    {% else %}
    {{ prop_name | snake_case }}: {{ py_type }} | None = Field(
        None,
        description={{ (prop_schema.get('description', '') or '') | repr }},
    )
    {% endif %}
    {% endfor %}
    {% else %}
    model_config = {"extra": "allow"}
    {% endif %}

{% endfor %}

# ------------------------------------------------------------------ #
# Client
# ------------------------------------------------------------------ #

class EAPClient:
    """Async HTTP client for the {{ title }}.

    Supports both Bearer JWT and X-API-Key authentication.
    All methods are async and must be awaited.

    Args:
        base_url: API base URL (default: {{ base_url }}).
        bearer_token: JWT Bearer token for authentication.
        api_key: API key for authentication.
        timeout: HTTP request timeout in seconds (default: 30).
    """

    def __init__(
        self,
        base_url: str = "{{ base_url }}",
        bearer_token: str | None = None,
        api_key: str | None = None,
        timeout: float = 30.0,
    ) -> None:
        self._base_url = base_url.rstrip("/")
        self._bearer_token = bearer_token
        self._api_key = api_key
        self._timeout = timeout
        self._client: httpx.AsyncClient | None = None

    def _build_headers(self) -> dict[str, str]:
        headers: dict[str, str] = {"Content-Type": "application/json"}
        if self._bearer_token:
            headers["Authorization"] = f"Bearer {self._bearer_token}"
        elif self._api_key:
            headers["X-API-Key"] = self._api_key
        return headers

    async def _request(
        self,
        method: str,
        path: str,
        *,
        params: dict[str, Any] | None = None,
        body: Any = None,
    ) -> Any:
        url = f"{self._base_url}{path}"
        headers = self._build_headers()
        content: bytes | None = None
        if body is not None:
            if isinstance(body, BaseModel):
                content = body.model_dump_json(exclude_none=True).encode()
            else:
                content = json.dumps(body, default=str).encode()

        async with httpx.AsyncClient(timeout=self._timeout) as client:
            response = await client.request(
                method,
                url,
                headers=headers,
                params=params,
                content=content,
            )

        if response.status_code == 401:
            raise EAPAuthError(response.status_code, response.text)
        if response.status_code == 403:
            raise EAPForbiddenError(response.status_code, response.text)
        if response.status_code == 404:
            raise EAPNotFoundError(response.status_code, response.text)
        if response.status_code == 429:
            raise EAPRateLimitError(response.status_code, response.text)
        if response.status_code >= 400:
            raise EAPAPIError(response.status_code, response.text)

        if response.status_code == 204 or not response.content:
            return None

        return response.json()

    # ---------------------------------------------------------------- #
    # Generated methods
    # ---------------------------------------------------------------- #

{% for op in operations %}
    async def {{ op.operation_id | snake_case }}(
        self,
        {% for param in op.parameters %}
        {% if param.get('required', False) %}
        {{ param.name | snake_case }}: {{ python_type(param.get('schema', {})) }},
        {% else %}
        {{ param.name | snake_case }}: {{ python_type(param.get('schema', {})) }} | None = None,
        {% endif %}
        {% endfor %}
        {% if op.request_body %}
        body: dict[str, Any] | None = None,
        {% endif %}
    ) -> Any:
        """{{ op.summary or op.operation_id }}.

        {% if op.tags %}Tags: {{ op.tags | join(', ') }}{% endif %}
        Method: {{ op.method }}  Path: {{ op.path }}
        """
        path = "{{ op.path }}"
        {% for param in op.parameters %}
        {% if param.get('in') == 'path' %}
        path = path.replace("{{ '{' + param.name + '}' }}", str({{ param.name | snake_case }}))
        {% endif %}
        {% endfor %}
        params: dict[str, Any] = {}
        {% for param in op.parameters %}
        {% if param.get('in') == 'query' %}
        if {{ param.name | snake_case }} is not None:
            params[{{ param.name | repr }}] = {{ param.name | snake_case }}
        {% endif %}
        {% endfor %}
        return await self._request(
            "{{ op.method }}",
            path,
            {% if op.parameters | selectattr('in', 'equalto', 'query') | list %}
            params=params or None,
            {% endif %}
            {% if op.request_body %}
            body=body,
            {% endif %}
        )

{% endfor %}
