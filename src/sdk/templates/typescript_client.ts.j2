// AUTO-GENERATED - do not edit manually.
// Generated by Enterprise Agent Platform SDK Generator v{{ version }}
// Source: {{ title }} {{ version }}
/**
 * {{ title }} TypeScript Client (auto-generated).
 *
 * Fetch-based client with TypeScript interfaces.
 *
 * @example
 * ```typescript
 * const client = new EAPClient({
 *   baseUrl: "{{ base_url }}",
 *   bearerToken: "<your-jwt-token>",  // or apiKey: "<key>"
 * });
 *
 * // Example: list webhooks
 * const webhooks = await client.listWebhooks();
 * console.log(webhooks);
 * ```
 */

// ------------------------------------------------------------------ //
// Exceptions
// ------------------------------------------------------------------ //

export class EAPAPIError extends Error {
  constructor(
    public readonly statusCode: number,
    public readonly detail: unknown,
  ) {
    super(`EAP API error ${statusCode}: ${JSON.stringify(detail)}`);
    this.name = "EAPAPIError";
  }
}

export class EAPAuthError extends EAPAPIError {
  constructor(statusCode: number, detail: unknown) {
    super(statusCode, detail);
    this.name = "EAPAuthError";
  }
}

export class EAPForbiddenError extends EAPAPIError {
  constructor(statusCode: number, detail: unknown) {
    super(statusCode, detail);
    this.name = "EAPForbiddenError";
  }
}

export class EAPNotFoundError extends EAPAPIError {
  constructor(statusCode: number, detail: unknown) {
    super(statusCode, detail);
    this.name = "EAPNotFoundError";
  }
}

export class EAPRateLimitError extends EAPAPIError {
  constructor(statusCode: number, detail: unknown) {
    super(statusCode, detail);
    this.name = "EAPRateLimitError";
  }
}

// ------------------------------------------------------------------ //
// TypeScript interfaces (generated from OpenAPI schemas)
// ------------------------------------------------------------------ //

{% for name, schema in schemas.items() %}
{% set props = schema.get('properties', {}) %}
{% set required_fields = schema.get('required', []) %}
/** {{ schema.get('description', name + ' interface.') }} */
export interface {{ name | pascal_case }} {
{% for prop_name, prop_schema in props.items() %}
  /** {{ prop_schema.get('description', '') }} */
  {% if prop_name in required_fields %}
  {{ prop_name }}: {{ ts_type(prop_schema) }};
  {% else %}
  {{ prop_name }}?: {{ ts_type(prop_schema) }};
  {% endif %}
{% endfor %}
}

{% endfor %}

// ------------------------------------------------------------------ //
// Client configuration
// ------------------------------------------------------------------ //

export interface EAPClientConfig {
  /** API base URL. Default: {{ base_url }} */
  baseUrl?: string;
  /** Bearer JWT token for authentication. */
  bearerToken?: string;
  /** API key for authentication. */
  apiKey?: string;
  /** Request timeout in milliseconds. Default: 30000 */
  timeoutMs?: number;
}

// ------------------------------------------------------------------ //
// Client
// ------------------------------------------------------------------ //

/** Async TypeScript client for the {{ title }}. */
export class EAPClient {
  private readonly baseUrl: string;
  private readonly bearerToken?: string;
  private readonly apiKey?: string;
  private readonly timeoutMs: number;

  constructor(config: EAPClientConfig = {}) {
    this.baseUrl = (config.baseUrl ?? "{{ base_url }}").replace(/\/$/, "");
    this.bearerToken = config.bearerToken;
    this.apiKey = config.apiKey;
    this.timeoutMs = config.timeoutMs ?? 30_000;
  }

  private buildHeaders(): Record<string, string> {
    const headers: Record<string, string> = {
      "Content-Type": "application/json",
    };
    if (this.bearerToken) {
      headers["Authorization"] = `Bearer ${this.bearerToken}`;
    } else if (this.apiKey) {
      headers["X-API-Key"] = this.apiKey;
    }
    return headers;
  }

  private async request<T>(
    method: string,
    path: string,
    options?: {
      params?: Record<string, unknown>;
      body?: unknown;
    },
  ): Promise<T> {
    let url = `${this.baseUrl}${path}`;

    if (options?.params) {
      const qs = new URLSearchParams(
        Object.entries(options.params)
          .filter(([, v]) => v !== undefined && v !== null)
          .map(([k, v]) => [k, String(v)]),
      ).toString();
      if (qs) url += `?${qs}`;
    }

    const controller = new AbortController();
    const timeoutId = setTimeout(() => controller.abort(), this.timeoutMs);

    let response: Response;
    try {
      response = await fetch(url, {
        method,
        headers: this.buildHeaders(),
        body: options?.body !== undefined ? JSON.stringify(options.body) : undefined,
        signal: controller.signal,
      });
    } finally {
      clearTimeout(timeoutId);
    }

    if (response.status === 401) {
      throw new EAPAuthError(response.status, await response.text());
    }
    if (response.status === 403) {
      throw new EAPForbiddenError(response.status, await response.text());
    }
    if (response.status === 404) {
      throw new EAPNotFoundError(response.status, await response.text());
    }
    if (response.status === 429) {
      throw new EAPRateLimitError(response.status, await response.text());
    }
    if (!response.ok) {
      throw new EAPAPIError(response.status, await response.text());
    }
    if (response.status === 204 || response.headers.get("content-length") === "0") {
      return undefined as unknown as T;
    }
    return (await response.json()) as T;
  }

  // ---------------------------------------------------------------- //
  // Generated methods
  // ---------------------------------------------------------------- //

{% for op in operations %}
  /**
   * {{ op.summary or op.operation_id }}
   * {% if op.tags %}Tags: {{ op.tags | join(', ') }}{% endif %}
   * `{{ op.method }} {{ op.path }}`
   */
  async {{ op.operation_id | camel_case }}(
    {% for param in op.parameters %}
    {{ param.name | camel_case }}{% if not param.get('required', False) %}?{% endif %}: {{ ts_type(param.get('schema', {})) }},
    {% endfor %}
    {% if op.request_body %}
    body?: Record<string, unknown>,
    {% endif %}
  ): Promise<unknown> {
    let path = "{{ op.path }}";
    {% for param in op.parameters %}
    {% if param.get('in') == 'path' %}
    path = path.replace("{{ '{' + param.name + '}' }}", String({{ param.name | camel_case }}));
    {% endif %}
    {% endfor %}
    const params: Record<string, unknown> = {};
    {% for param in op.parameters %}
    {% if param.get('in') == 'query' %}
    if ({{ param.name | camel_case }} !== undefined) params["{{ param.name }}"] = {{ param.name | camel_case }};
    {% endif %}
    {% endfor %}
    return this.request("{{ op.method }}", path, {
      {% if op.parameters | selectattr('in', 'equalto', 'query') | list %}
      params,
      {% endif %}
      {% if op.request_body %}
      body,
      {% endif %}
    });
  }

{% endfor %}
}
